package tzc

import (
	"bytes"
	"github.com/ngrash/go-tz/tzif"
	"strings"
)

type builder struct {
	d tzif.Data
}

func (b *builder) addTransition(t int64) {
	b.d.V2Data.TransitionTimes = append(b.d.V2Data.TransitionTimes, t)
}

func (b *builder) addDesignation(format, letter string) uint8 {
	desig := format
	if strings.Contains(format, "%s") {
		desig = strings.ReplaceAll(format, "%s", letter)
	}
	if idx := bytes.Index(b.d.V2Data.TimeZoneDesignation, append([]byte(desig), 0x00)); idx != -1 {
		return uint8(idx)
	}
	idx := uint8(len(b.d.V2Data.TimeZoneDesignation))
	b.d.V2Data.TimeZoneDesignation = append(b.d.V2Data.TimeZoneDesignation, append([]byte(desig), 0x00)...)
	return idx
}

func (b *builder) minimalV1Compliance() {
	// For now, we only support the 'slim' tzif format as generated by `zic -b slim`.
	// That means, we skip the V1 header entirely and only place a dummy record there
	// so old programs don't crash.
	b.d.V1Header.Version = tzif.V2 // TODO: Adjust if we build V3+.
	b.d.V1Header.Typecnt = 1
	b.d.V1Header.Charcnt = 1
	b.d.V1Data.LocalTimeTypeRecord = []tzif.LocalTimeTypeRecord{{Utoff: 0, Dst: false, Idx: 0}}
	b.d.V1Data.TimeZoneDesignation = []byte{0x00}
}

func (b *builder) deriveV2HeaderFromData() {
	b.d.V2Header.Version = tzif.V2
	b.d.V2Header.Timecnt = uint32(len(b.d.V2Data.TransitionTimes))
	b.d.V2Header.Typecnt = uint32(len(b.d.V2Data.LocalTimeTypeRecord))
	b.d.V2Header.Charcnt = uint32(len(b.d.V2Data.TimeZoneDesignation))
}

func (b *builder) setFooter(tzstring string) {
	b.d.V2Footer.TZString = []byte(tzstring)
}

func (b *builder) Data() tzif.Data {
	b.d.Version = tzif.V2
	return b.d
}
